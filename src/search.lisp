(load "./src/movegen.lisp")

(defvar fen14 "r3k1nr/1bppqppp/4p3/4P3/1PpP4/2PB1N2/5PPP/R2Q1RK1 w kq - 0 1")

(defvar fen13 "r3k1nr/1bppqppp/4p3/4P3/1PpP4/2PB1N2/5PPP/R2Q1RK1 w kq - 0 1")
(defvar fen12 "r3k3/1b6/8/8/8/8/8/R3K3 w kq - 0 1")
(defvar fen11 "1k6/1Q6/8/1R6/8/8/8/3K4 b - - 0 1")
(defvar fen10 "8/4k3/4p3/5B2/4R3/4K3/8/8 b - - 0 1")
(defvar fen9 "8/rppk3Q/p2p4/5r2/8/7P/5PP1/4R1K1 b - - 0 1")
(defvar fen8 "r3k2r/1bpp1pp1/p3p3/1p2RP1p/8/3B3P/P1P3P1/1R4K1 b KQkq - 0 1")
(defvar fen7 "r1b1k3/1pp2pp1/p6r/3p3p/2P5/1P1B1N1P/3Q1PP1/R5K1 w - - 0 1")
(defvar fen "6k1/r7/4n1Q1/8/6K1/2bb4/8/8 b - - 0 0")
(defvar fen2 "4k3/8/8/8/8/8/8/4K2R w - - 0 1")
(defvar fen3 "r3k3/8/8/8/3p4/8/4P3/4K2R w Kq - 0 1")
(defvar fen4 "r3k3/8/8/8/3R4/8/4P3/4K3 w - - 0 1")
(defvar fen5 "4k3/8/8/8/8/8/4P3/4K3 w - - 0 1")
(defvar fen6 "8/8/8/8/8/8/6k1/3KR1q1 w - - 0 1")

(defun getfrom (move) (logand (ash move -6) 63))
(defun getto (move) (logand move 63))
(defun getflag (move) (ash move -12))

(defun simple-eval (b)
  (let* ((color (color b))
	 (copy b)
	 (boards (boards b))
	 (wki (bitLength (aref boards white king)))
	 (bki (bitLength (aref boards black king)))
	 (wq (bitLength (aref boards white queen)))
	 (bq (bitLength (aref boards black queen)))
	 (wr (bitLength (aref boards white rook)))
	 (br (bitLength (aref boards black rook)))
	 (wb (bitLength (aref boards white bishop)))
	 (bb (bitLength (aref boards black bishop)))
	 (wk (bitLength (aref boards white knight)))
	 (bk (bitLength (aref boards black knight)))
	 (wp (bitLength (aref boards white pawn)))
	 (bp (bitLength (aref boards black pawn)))
         (wm (progn  
	       (setColor copy white) 
	       (length (generate-all-moves copy))))
	 (bm (progn  
	       (setColor copy black) 
	       (length (generate-all-moves copy))))
	 (val (+ (* 200 (- wki bki))
		 (* 9 (- wq bq))
		 (* 5 (- wr br))
		 (* 3 (+ (- wb bb) (- wk bk)))
		 (* 1 (- wp bp))
		 (* 0.1 (- wm bm)))))
    (setColor copy color)
    val
   ))

(defun alphaBeta (b alpha beta depthleft)
  (let* ((isCheck (isChecked b))
	 (moves (if isCheck
		    (genCheckEvasions b)
		  (generate-all-moves b)))
	 (m '())
	 (bestscore -1000))
    (if (= depthleft 0) (simple-eval b)      
      (if (loop for move in moves do
		(applyMove b move)
		(if (opIsChecked b)
		    (popMove b)
		  (let* ((score (- (alphaBeta b (- beta) (- alpha)  (- depthleft 1)))))

		    (popMove b)
		    (if (>= score beta) (return t))
		    (if (> score bestscore) 
			(progn
			  (setq bestscore score)
			  (if (> score alpha)
			      (setq alpha score))
			  (setq m move))))))
	  (values beta m)
	(values alpha m)))))

(defun getResult (b alpha beta depth)
  (multiple-value-bind (score move) (alphaBeta b alpha beta depth)(list score move)))
